P = K.copy()
for n in K.nodes:
opchange = []
    for j in K.neighbors(n):
        if K.nodes[j]['relevance'] >= threshold:
            if (n, j) in sub:
                if [n, j] in simmelian:
                    if BC[n] - BC[j] < 0:
                        p = randrange(psimmvertup1, psimmvertup2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psub) + (
                                P.nodes[j]['relevance']) * psub)
                    elif BC[n] - BC[j] > 0:
                        p = randrange(psimmvertdown1, psimmvertdown2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psub) + (
                                P.nodes[j]['relevance']) * psub)
                    elif BC[n] - BC[j] == 0:
                        p = randrange(psimmhor1, psimmhor2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psub) + (
                                P.nodes[j]['relevance']) * psub)
                else:
                    if BC[n] - BC[j] < 0:
                        p = randrange(pvertup1, pvertup2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psub) + (
                                P.nodes[j]['relevance']) * psub)
                    elif BC[n] - BC[j] > 0:
                        p = randrange(pvertdown1, pvertdown2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psub) + (
                                P.nodes[j]['relevance']) * psub)
                    elif BC[n] - BC[j] == 0:
                        p = randrange(phor1, phor2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psub) + (
                                P.nodes[j]['relevance']) * psub)
            if (n, j) in sup:
                if [n, j] in simmelian:
                    if BC[n] - BC[j] < 0:
                        p = randrange(psimmvertup1, psimmvertup2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psup) + (
                                P.nodes[j]['relevance']) * psup)
                    elif BC[n] - BC[j] > 0:
                        p = randrange(psimmvertdown1, psimmvertdown2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psup) + (
                                P.nodes[j]['relevance']) * psup)
                    elif BC[n] - BC[j] == 0:
                        p = randrange(psimmhor1, psimmhor2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psup) + (
                                P.nodes[j]['relevance']) * psup)
                else:
                    if BC[n] - BC[j] < 0:
                        p = randrange(pvertup1, pvertup2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psup) + (
                                P.nodes[j]['relevance']) * psup)
                    elif BC[n] - BC[j] > 0:
                        p = randrange(pvertdown1, pvertdown2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psup) + (
                                P.nodes[j]['relevance']) * psup)
                    elif BC[n] - BC[j] == 0:
                        p = randrange(phor1, phor2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - psup) + (
                                P.nodes[j]['relevance']) * psup)
            else:
                if [n, j] in simmelian:
                    if BC[n] - BC[j] < 0:
                        p = randrange(psimmvertup1, psimmvertup2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - pnorm) + (
                                P.nodes[j]['relevance']) * pnorm)
                    elif BC[n] - BC[j] > 0:
                        p = randrange(psimmvertdown1, psimmvertdown2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - pnorm) + (
                                P.nodes[j]['relevance']) * pnorm)
                    elif BC[n] - BC[j] == 0:
                        p = randrange(psimmhor1, psimmhor2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - pnorm) + (
                                P.nodes[j]['relevance']) * pnorm)
                else:
                    if BC[n] - BC[j] < 0:
                        p = randrange(pvertup1, pvertup2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - pnorm) + (
                                P.nodes[j]['relevance']) * pnorm)
                    elif BC[n] - BC[j] > 0:
                        p = randrange(pvertdown1, pvertdown2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - pnorm) + (
                                P.nodes[j]['relevance']) * pnorm)
                    elif BC[n] - BC[j] == 0:
                        p = randrange(phor1, phor2) / 100
                        if random.random() < p:
                            opchange.append((P.nodes[n]['relevance']) * (1 - pnorm) + (
                                P.nodes[j]['relevance']) * pnorm)
    K.nodes[n]["relevance"] = np.average()
