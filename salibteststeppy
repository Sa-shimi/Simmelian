import random
import SALib.sample.morris
import networkx as nx
import pandas as pd
from itertools import combinations
from random import randrange
from SALib.analyze.morris import analyze
import statistics as s
import numpy as np


def test(psimmvertup1, psimmvertup2, psimmvertdown1, psimmvertdown2, psimmhor1, psimmhor2, pvertup1, pvertup2,
         pvertdown1,
         pvertdown2, phor1, phor2, psup, psub, pnorm, threshold, num, p):
    psimmvertup1 = int(psimmvertup1)
    # 20/70
    psimmvertup2 = int(psimmvertup2)
    # 20/70
    psimmvertdown1 = int(psimmvertdown1)
    # 20/70
    psimmvertdown2 = int(psimmvertdown2)
    # 20/70
    psimmhor1 = int(psimmhor1)
    # 20/70
    psimmhor2 = int(psimmhor2)
    # 20/70
    pvertup1 = int(pvertup1)
    # 20/70
    pvertup2 = int(pvertup2)
    # 20/70
    pvertdown1 = int(pvertdown1)
    # 20/70
    pvertdown2 = int(pvertdown2)
    # 20/70
    phor1 = int(phor1)
    # 20/70
    phor2 = int(phor2)
    # 20/70

    # willingness to be influenced by, respectively, subordinates, superiors and peers
    psub = psub
    # 0.01
    psup = psup
    # 0.1
    pnorm = pnorm
    # 0.3
    threshold = threshold
    # 0.7

    p = int(p)
    num = int(num)
    F = nx.random_tree(n=num, create_using=nx.DiGraph, )
    G = nx.barabasi_albert_graph(num, p)

    def Control_Centrality(F):
        length = len(F.nodes)
        i = 1

        def CC(F):
            pippa = F.out_degree()
            pippa1 = np.array(pippa)
            pippa2 = pippa1[pippa1[:, 1] != 0]
            F = F.subgraph(pippa2[:, 0])
            return F

        def layer(F):
            culo = [x for x in F.nodes if x not in CC(F).nodes]
            banana = [i] * len(culo)
            results = np.column_stack((culo, banana))
            return results

        results = layer(F)
        while len(results) < length:
            results = np.concatenate([results, layer(F)])
            results = np.unique(results, axis=0)
            i += 1
            F = CC(F)
            layer(F)
        return dict(zip(results[:, 0], (results[:, 1])))

    BC = Control_Centrality(F)
    cliques = list(nx.enumerate_all_cliques(G))

    triads = [i for i in cliques if len(i) == 3]

    def combine(arr, s):
        return list(combinations(arr, s))

    simm = []
    for n in triads:
        for l in combine(n, 2):
            simm.append(l)

    simmelian = []
    for i in simm:
        if i not in simmelian:
            simmelian.append(i)

    simmelian = np.array(simmelian)
    A = simmelian[:, 0]
    B = simmelian[:, 1]
    df = pd.DataFrame(simmelian)
    numsimm = len(simmelian)

    BCA = []
    for x in (A):
        for n in (BC):
            if x == n:
                BCA.append(BC[n])
    BCB = []
    for y in (B):
        for n in (BC):
            if y == n:
                BCB.append(BC[n])

    df['BCA'] = BCA
    df['BCB'] = BCB
    df['AVG'] = (df['BCA'] + df['BCB']) / 2
    df['VAR'] = (((df['BCA'] - df['AVG']) ** 2 + (df['BCB'] - df['AVG']) ** 2) / 2)
    VAR = np.sum(df['VAR'])

    sub = []
    for (i, j) in F.edges:
        sub.append((j, i))

    sup = F.edges

    nx.set_edge_attributes(G, 0, name='prob')
    nx.set_node_attributes(G, 0, name='relevance')
    G.nodes[0]['relevance'] = 1

    def steppy(G):
        K = G.copy()
        t = 1

        def event(G):

            P = K.copy()
            for n in K.nodes:
                global influencejn
                opchange = []
                for j in K.neighbors(n):
                    if P.nodes[j]['relevance'] >= threshold:
                        if (n, j) in sub:
                            if [n, j] in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(psimmvertup1, psimmvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(psimmvertdown1, psimmvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(psimmhor1, psimmhor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                            elif [n, j] not in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(pvertup1, pvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(pvertdown1, pvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(phor1, phor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                        elif (n, j) in sup:
                            if [n, j] in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(psimmvertup1, psimmvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(psimmvertdown1, psimmvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(psimmhor1, psimmhor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                            elif [n, j] not in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(pvertup1, pvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(pvertdown1, pvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(phor1, phor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                        else:
                            if [n, j] in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(psimmvertup1, psimmvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(psimmvertdown1, psimmvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(psimmhor1, psimmhor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                            elif [n, j] not in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(pvertup1, pvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(pvertdown1, pvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(phor1, phor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                if np.size(opchange) == 0:
                    K.nodes[n]['relevance'] = P.nodes[n]['relevance']
                else:
                    K.nodes[n]["relevance"] = np.average(opchange)
            return K

        K = event(K)
        for n in K.nodes:
            while K.nodes[n]['relevance'] <= threshold:
                t += 1
                event(K)
        return float(t)

    return (steppy(G))


print(test(20, 70, 20, 70, 20, 70, 10, 70, 10, 70, 5, 70, 0.01, 0.05, 0.3, 0.7, 50, 3))

problem = {
    'num_vars': 18,
    'names': ['psimmvertup1', 'psimmvertup2', 'psimmvertdown1', 'psimmvertdown2', 'psimmhor1', 'psimmhor2', 'pvertup1',
              'pvertup2', 'pvertdown1', 'pvertdown2', 'phor1', 'phor2', 'psup', 'psub', 'pnorm',
              'threshold', 'num', 'p'],
    'bounds': [[10, 30],
               [60, 80],
               [10, 30],
               [60, 80],
               [10, 30],
               [60, 80],
               [10, 30],
               [60, 80],
               [10, 30],
               [60, 80],
               [10, 30],
               [60, 80],
               [0.1, 0.99],
               [0.1, 0.99],
               [0.1, 0.99],
               [0.3, 0.99],
               [20, 500],
               [2, 10]
               ]
}

param_values = SALib.sample.morris.sample(problem, 2 ** 2)
Y = np.array([test(*params) for params in param_values])
si = analyze(problem, param_values, Y, num_resamples=2 ** 2, print_to_console=True)



print(si)
print('number of samples:', len(param_values))

print('min steps:', min(Y))
print('max steps:', max(Y))
print('mean steps',s.mean(Y))
print('quantiles steps:', s.quantiles(Y))

print('min simmvertup1:', min(param_values[:, 0]))
print('min simmvertup2:', min(param_values[:, 1]))
print('min simmvertdown1:', min(param_values[:, 2]))
print('min simmvertdown2:', min(param_values[:, 3]))
print('min simmhor1:', min(param_values[:, 4]))
print('min simmhor2:', min(param_values[:, 5]))
print('min pvertup1:', min(param_values[:, 6]))
print('min pvertup2:', min(param_values[:, 7]))
print('min pvertdown1:', min(param_values[:, 8]))
print('min pvertdown2:', min(param_values[:, 9]))
print('min phor1:', min(param_values[:, 10]))
print('min phor2:', min(param_values[:, 11]))
print('min psup:', min(param_values[:, 12]))
print('min psub:', min(param_values[:, 13]))
print('min pnorm:', min(param_values[:, 14]))
print('min threshold:', min(param_values[:, 15]))
print('min num:', min(param_values[:, 16]))
print('min p:', min(param_values[:, 17]))

print('max simmvertup1:', max(param_values[:, 0]))
print('max simmvertup2:', max(param_values[:, 1]))
print('max simmvertdown1:', max(param_values[:, 2]))
print('max simmvertdown2:', max(param_values[:, 3]))
print('max simmhor1:', max(param_values[:, 4]))
print('max simmhor2:', max(param_values[:, 5]))
print('max pvertup1:', max(param_values[:, 6]))
print('max pvertup2:', max(param_values[:, 7]))
print('max pvertdown1:', max(param_values[:, 8]))
print('max pvertdown2:', max(param_values[:, 9]))
print('max phor1:', max(param_values[:, 10]))
print('max phor2:', max(param_values[:, 11]))
print('max psup:', max(param_values[:, 12]))
print('max psub:', max(param_values[:, 13]))
print('max pnorm:', max(param_values[:, 14]))
print('max threshold:', max(param_values[:, 15]))
print('max num:', max(param_values[:, 16]))
print('max p:', max(param_values[:, 17]))

print('mean simmvertup1:', s.mean(param_values[:, 0]))
print('mean simmvertup2:', s.mean(param_values[:, 1]))
print('mean simmvertdown1:', s.mean(param_values[:, 2]))
print('mean simmvertdown2:', s.mean(param_values[:, 3]))
print('mean simmhor1:', s.mean(param_values[:, 4]))
print('mean simmhor2:', s.mean(param_values[:, 5]))
print('mean pvertup1:', s.mean(param_values[:, 6]))
print('mean pvertup2:', s.mean(param_values[:, 7]))
print('mean pvertdown1:', s.mean(param_values[:, 8]))
print('mean pvertdown2:', s.mean(param_values[:, 9]))
print('mean phor1:', s.mean(param_values[:, 10]))
print('mean phor2:', s.mean(param_values[:, 11]))
print('mean psup:', s.mean(param_values[:, 12]))
print('mean psub:', s.mean(param_values[:, 13]))
print('mean pnorm:', s.mean(param_values[:, 14]))
print('mean threshold:', s.mean(param_values[:, 15]))
print('mean num:', s.mean(param_values[:, 16]))
print('mean p:', s.mean(param_values[:, 17]))

print('quantiles simmvertup1:', s.quantiles(param_values[:, 0]))
print('quantiles simmvertup2:', s.quantiles(param_values[:, 1]))
print('quantiles simmvertdown1:', s.quantiles(param_values[:, 2]))
print('quantiles simmvertdown2:', s.quantiles(param_values[:, 3]))
print('quantiles simmhor1:', s.quantiles(param_values[:, 4]))
print('quantiles simmhor2:', s.quantiles(param_values[:, 5]))
print('quantiles pvertup1:', s.quantiles(param_values[:, 6]))
print('quantiles pvertup2:', s.quantiles(param_values[:, 7]))
print('quantiles pvertdown1:', s.quantiles(param_values[:, 8]))
print('quantiles pvertdown2:', s.quantiles(param_values[:, 9]))
print('quantiles phor1:', s.quantiles(param_values[:, 10]))
print('quantiles phor2:', s.quantiles(param_values[:, 11]))
print('quantiles psup:', s.quantiles(param_values[:, 12]))
print('quantiles psub:', s.quantiles(param_values[:, 13]))
print('quantiles pnorm:', s.quantiles(param_values[:, 14]))
print('quantiles threshold:', s.quantiles(param_values[:, 15]))
print('quantiles num:', s.quantiles(param_values[:, 16]))
print('quantiles p:', s.quantiles(param_values[:, 17]))
