
from SALib.util import (scale_samples, read_param_file,
                    compute_groups_matrix, _check_groups)

import SALib.sample.sobol_sequence as sobol_sequence
import random
import SALib.sample.morris
import networkx as nx
import pandas as pd
from itertools import combinations
from random import randrange
from SALib.analyze.morris import analyze
import statistics as s
import numpy as np
from typing import Dict, Optional
import math
import warnings




def test(psimmvertup, psimmvertdown, psimmhor, pvertup,
         pvertdown, phor, psup, psub, pnorm, threshold, num, p):
    psimmvertup1 = int(psimmvertup-10)
    psimmvertup2 = int(psimmvertup+10)
    psimmvertdown1 = int(psimmvertdown-10)
    psimmvertdown2 = int(psimmvertdown+10)
    psimmhor1 = int(psimmhor-10)
    psimmhor2 = int(psimmhor+10)
    pvertup1 = int(pvertup-10)
    pvertup2 = int(pvertup+10)
    pvertdown1 = int(pvertdown-10)
    pvertdown2 = int(pvertdown+10)
    phor1 = int(phor-10)
    phor2 = int(phor+10)

    # willingness to be influenced by, respectively, subordinates, superiors and peers
    psub = psub
    # 0.01
    psup = psup
    # 0.1
    pnorm = pnorm
    # 0.3
    threshold = threshold
    # 0.7

    p = int(p)
    num = int(num)
    F = nx.random_tree(n=num, create_using=nx.DiGraph, )
    G = nx.barabasi_albert_graph(num, p)

    def Control_Centrality(F):
        length = len(F.nodes)
        i = 1

        def CC(F):
            pippa = F.out_degree()
            pippa1 = np.array(pippa)
            pippa2 = pippa1[pippa1[:, 1] != 0]
            F = F.subgraph(pippa2[:, 0])
            return F

        def layer(F):
            culo = [x for x in F.nodes if x not in CC(F).nodes]
            banana = [i] * len(culo)
            results = np.column_stack((culo, banana))
            return results

        results = layer(F)
        while len(results) < length:
            results = np.concatenate([results, layer(F)])
            results = np.unique(results, axis=0)
            i += 1
            F = CC(F)
            layer(F)
        return dict(zip(results[:, 0], (results[:, 1])))

    BC = Control_Centrality(F)
    cliques = list(nx.enumerate_all_cliques(G))

    triads = [i for i in cliques if len(i) == 3]

    def combine(arr, s):
        return list(combinations(arr, s))

    simm = []
    for n in triads:
        for l in combine(n, 2):
            simm.append(l)

    simmelian = []
    for i in simm:
        if i not in simmelian:
            simmelian.append(i)

    simmelian = np.array(simmelian)
    A = simmelian[:, 0]
    B = simmelian[:, 1]
    df = pd.DataFrame(simmelian)
    numsimm = len(simmelian)

    BCA = []
    for x in (A):
        for n in (BC):
            if x == n:
                BCA.append(BC[n])
    BCB = []
    for y in (B):
        for n in (BC):
            if y == n:
                BCB.append(BC[n])

    df['BCA'] = BCA
    df['BCB'] = BCB
    df['AVG'] = (df['BCA'] + df['BCB']) / 2
    df['VAR'] = (((df['BCA'] - df['AVG']) ** 2 + (df['BCB'] - df['AVG']) ** 2) / 2)
    VAR = np.sum(df['VAR'])

    sub = []
    for (i, j) in F.edges:
        sub.append((j, i))

    sup = F.edges

    nx.set_edge_attributes(G, 0, name='prob')
    nx.set_node_attributes(G, 0, name='relevance')
    G.nodes[0]['relevance'] = 1

    def steppy(G):
        K = G.copy()
        t = 1

        def event(G):

            P = K.copy()
            for n in K.nodes:
                global influencejn
                opchange = []
                for j in K.neighbors(n):
                    if P.nodes[j]['relevance'] >= threshold:
                        if (n, j) in sub:
                            if [n, j] in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(psimmvertup1, psimmvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(psimmvertdown1, psimmvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(psimmhor1, psimmhor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                            elif [n, j] not in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(pvertup1, pvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(pvertdown1, pvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(phor1, phor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psub) + (
                                            P.nodes[j]['relevance']) * psub
                                        opchange.append(influencejn)
                        elif (n, j) in sup:
                            if [n, j] in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(psimmvertup1, psimmvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(psimmvertdown1, psimmvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(psimmhor1, psimmhor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                            elif [n, j] not in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(pvertup1, pvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(pvertdown1, pvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(phor1, phor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - psup) + (
                                            P.nodes[j]['relevance']) * psup
                                        opchange.append(influencejn)
                        else:
                            if [n, j] in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(psimmvertup1, psimmvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(psimmvertdown1, psimmvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(psimmhor1, psimmhor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                            elif [n, j] not in simmelian:
                                if BC[n] - BC[j] < 0:
                                    p = randrange(pvertup1, pvertup2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] > 0:
                                    p = randrange(pvertdown1, pvertdown2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                                elif BC[n] - BC[j] == 0:
                                    p = randrange(phor1, phor2) / 100
                                    if random.random() < p:
                                        influencejn = (P.nodes[n]['relevance']) * (1 - pnorm) + (
                                            P.nodes[j]['relevance']) * pnorm
                                        opchange.append(influencejn)
                if np.size(opchange) == 0:
                    K.nodes[n]['relevance'] = P.nodes[n]['relevance']
                else:
                    K.nodes[n]["relevance"] = np.average(opchange)
            return K

        K = event(K)
        for n in K.nodes:
            while K.nodes[n]['relevance'] <= threshold:
                t += 1
                event(K)
        return float(t)

    return (steppy(G))


print(test(30,40,50,60,70,80, 0.01, 0.05, 0.3, 0.7, 50, 3))

problem = {
    'num_vars': 12,
    'names': ['psimmvertup', 'psimmvertdown', 'psimmhor', 'pvertup', 'pvertdown', 'phor', 'psup', 'psub', 'pnorm',
              'threshold', 'num', 'p'],
    'bounds': [[11, 89],
               [11, 89],
               [11, 89],
               [11, 89],
               [11, 89],
               [11, 89],
               [0.1, 0.99],
               [0.1, 0.99],
               [0.1, 0.99],
               [0.3, 0.99],
               [40, 50],
               [2, 10]
               ]
}

def sample(problem: Dict, N: int, calc_second_order: bool = True,
           skip_values: int = None):

    if not ((N & (N-1) == 0) and (N != 0 and N-1 != 0)):
        msg = f"""
        Convergence properties of the Sobol' sequence is only valid if
        `N` ({N}) is equal to `2^n`.
        """
        warnings.warn(msg)
    if skip_values is None:
        skip_values = int(2**math.ceil(math.log(N)/math.log(2)))
        skip_values = max(skip_values, 16)
    elif skip_values > 0:
        M = skip_values
        if not ((M & (M-1) == 0) and (M != 0 and M-1 != 0)):
            msg = f"""
            Convergence properties of the Sobol' sequence is only valid if
            `skip_values` ({M}) is a power of 2.
            """
            warnings.warn(msg)
        n_exp = int(math.log(N, 2))
        m_exp = int(math.log(M, 2))
        if n_exp > m_exp:
            msg = (
                "Convergence may not be valid as the number of requested samples is"
                f" > `skip_values` ({N} > {M})."
            )
            warnings.warn(msg)
    elif skip_values == 0:
        warnings.warn("Duplicate samples will be taken as no points are skipped.")
    else:
        assert isinstance(skip_values, int) and skip_values >= 0, \
            "`skip_values` must be a positive integer."
    D = problem['num_vars']
    groups = _check_groups(problem)
    if not groups:
        Dg = problem['num_vars']
    else:
        G, group_names = compute_groups_matrix(groups)
        Dg = len(set(group_names))
    base_sequence = sobol_sequence.sample(N + skip_values, 2 * D)
    if calc_second_order:
        saltelli_sequence = np.zeros([(2 * Dg + 2) * N, D])
    else:
        saltelli_sequence = np.zeros([(Dg + 2) * N, D])
    index = 0

    for i in range(skip_values, N + skip_values):
        for j in range(D):
            saltelli_sequence[index, j] = base_sequence[i, j]
        index += 1
        for k in range(Dg):
            for j in range(D):
                if (not groups and j == k) or (groups and group_names[k] == groups[j]):
                    saltelli_sequence[index, j] = base_sequence[i, j + D]
                else:
                    saltelli_sequence[index, j] = base_sequence[i, j]
            index += 1
        if calc_second_order:
            for k in range(Dg):
                for j in range(D):
                    if (not groups and j == k) or (groups and group_names[k] == groups[j]):
                        saltelli_sequence[index, j] = base_sequence[i, j]
                    else:
                        saltelli_sequence[index, j] = base_sequence[i, j + D]
                index += 1
        for j in range(D):
            saltelli_sequence[index, j] = base_sequence[i, j + D]
        index += 1
    saltelli_sequence = scale_samples(saltelli_sequence, problem)

    return saltelli_sequence


param_values = sample(problem, 2 ** 2)
b=len(param_values)-1
print(b)



t=0
Y=np.array([(test(*param_values[t]))])
while t!=b:
    t+=1
    if (int((t/b)*100))/10 == int((t/b)*10):
        print(int((t/b)*100),'%')
    g=np.array([(test(*param_values[t]))])
    Y=np.append(Y,g)



    
        


L=np.array([test(*params) for params in param_values])
si = analyze(problem, param_values, Y, num_resamples=2 ** 2, print_to_console=True)



print(si)
print('number of samples:', len(param_values))

print('min steps:', min(Y))
print('max steps:', max(Y))
print('mean steps',s.mean(Y))
print('quantiles steps:', s.quantiles(Y))

print('min simmvertup:', min(param_values[:, 0]))
print('min simmvertdown:', min(param_values[:, 1]))
print('min simmhor:', min(param_values[:, 2]))
print('min vertup:', min(param_values[:, 3]))
print('min vertdown:', min(param_values[:, 4]))
print('min hor:', min(param_values[:, 5]))
print('min psup:', min(param_values[:, 6]))
print('min psub:', min(param_values[:, 7]))
print('min pnorm:', min(param_values[:, 8]))
print('min threshold:', min(param_values[:, 9]))
print('min num:', min(param_values[:, 10]))
print('min p:', min(param_values[:, 11]))

print('max simmvertup:', max(param_values[:, 0]))
print('max simmvertdown:', max(param_values[:, 1]))
print('max simmhor:', max(param_values[:, 2]))
print('max vertup:', max(param_values[:, 3]))
print('max vertdown:', max(param_values[:, 4]))
print('max hor:', max(param_values[:, 5]))
print('max psup:', max(param_values[:, 6]))
print('max psub:', max(param_values[:, 7]))
print('max pnorm:', max(param_values[:, 8]))
print('max threshold:', max(param_values[:, 9]))
print('max num:', max(param_values[:, 10]))
print('max p:', max(param_values[:, 11]))

print('mean simmvertup:', s.mean(param_values[:, 0]))
print('mean simmvertdown:', s.mean(param_values[:, 1]))
print('mean simmhor:', s.mean(param_values[:, 2]))
print('mean vertup:', s.mean(param_values[:, 3]))
print('mean vertdown:', s.mean(param_values[:, 4]))
print('mean hor:', s.mean(param_values[:, 5]))
print('mean psup:', s.mean(param_values[:, 6]))
print('mean psub:', s.mean(param_values[:, 7]))
print('mean pnorm:', s.mean(param_values[:, 8]))
print('mean threshold:', s.mean(param_values[:, 9]))
print('mean num:', s.mean(param_values[:, 10]))
print('mean p:', s.mean(param_values[:, 11]))

print('quantiles simmvertup:', s.quantiles(param_values[:, 0]))
print('quantiles simmvertdown:', s.quantiles(param_values[:, 1]))
print('quantiles simmhor:', s.quantiles(param_values[:, 2]))
print('quantiles vertup:', s.quantiles(param_values[:, 3]))
print('quantiles vertdown:', s.quantiles(param_values[:, 4]))
print('quantiles hor:', s.quantiles(param_values[:, 5]))
print('quantiles psup:', s.quantiles(param_values[:, 6]))
print('quantiles psub:', s.quantiles(param_values[:, 7]))
print('quantiles pnorm:', s.quantiles(param_values[:, 8]))
print('quantiles threshold:', s.quantiles(param_values[:, 9]))
print('quantiles num:', s.quantiles(param_values[:, 10]))
print('quantiles p:', s.quantiles(param_values[:, 11]))

